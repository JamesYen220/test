# Week One: Learning x86_64 Commands

## Task
汇编冒泡排序
1. 写一个main.c，包含 main 函数，main 函数接受 N 和 N 个整数的输入
2. 写一个bubble_sort.S，用 GNU 汇编写冒泡排序，了解 Calling Convention（调用约定）
3. 使用 CMake 或 Makefile 链接为一个可执行文件
4. 再编译一个用 C 语言实现的冒泡排序，用不同的编译配置
5. 比较两者的性能：不同的输入规模，两者的运行时间比较
6. 所有工作内容在 GitHub 提交

## Calling Convention  
https://en.wikipedia.org/wiki/Calling_convention  
https://www.youtube.com/watch?v=uyRZRnJLqEY  
https://www.youtube.com/watch?v=iJYx5lJaEKM    

## GNU Assembly

### What is GNU
GNU is an extensive collection of free software, which can be used as an operating system or can run alongside other systems. Its name is a recursive acronym for "GNU's Not Unix," emphasizing its intention to provide a Unix-compatible software system that is free software.

The GNU Project was launched in 1983 by Richard Stallman with the goal of creating a free Unix-like operating system. This initiative was motivated by Stallman's desire to create a community of cooperation and sharing in the software world. The GNU General Public License (GPL), also introduced by Stallman, is a cornerstone of the GNU Project. It is a widely used free software license, ensuring that all derivatives of GNU software remain free.

Key components of the GNU system include the GNU Compiler Collection (GCC), the GNU C Library (glibc), and the GNU Core Utilities (coreutils). These elements provide essential functionality that allows the system to operate and be developed further. 

However, while GNU provides many of the necessary components of an operating system, it does not include a kernel (the core component that manages system resources). The GNU Hurd is the official kernel of the GNU Project, but it is not widely used. Instead, the Linux kernel, created by Linus Torvalds and also free software, is commonly used in conjunction with GNU components. This combination is often referred to as Linux, but more accurately, it should be called GNU/Linux, acknowledging both major parts of the system.  

### GNU Assembler VS GNU Compiler
1. **GNU Assembler (GAS)**: The GNU Assembler is a part of the GNU Binutils package and is the assembler used in the GNU system. An assembler is a tool that converts assembly language code into machine code. GAS is used to compile assembly language code into object code, which can then be linked into executable programs. It supports a wide range of architectures and is designed to work closely with the GNU Compiler Collection.

2. **GNU Compiler Collection (GCC)**: GCC is a compiler system produced by the GNU Project supporting various programming languages. GCC is a key part of the GNU toolchain and is the standard compiler for most Unix-like operating systems. It is responsible for converting source code written in languages like C, C++, and Fortran into executable machine code. GCC is renowned for its portability, robustness, and wide usage in various software projects.

When you compile a program with GCC, especially if it contains assembly code or needs to be linked with other object files or libraries, tools from Binutils, including GAS, are used. GCC typically invokes these tools automatically during the compilation and linking process. For example, when GCC compiles a program, it might first use GAS to assemble any assembly language code into object code, and then use `ld` (the linker from Binutils) to link these object files into a final executable.

If you're writing code entirely in assembly language, you can directly use the GNU Assembler (GAS) to translate your assembly code into machine code. In this scenario, there's no need for the GNU Compiler Collection (GCC), because GCC's primary function is to compile high-level programming languages like C, C++, or Fortran into assembly code, which is then assembled into machine code.


## Creating Enviornment  
Seems like even with Rosetta 2 on Mac, we need to create x86_64 enviornment on Docker  
Create Dockerfile
```
# Use an official Ubuntu base image (x86-64)
FROM ubuntu:20.04

# Set the maintainer label (optional)
LABEL maintainer="your-email@example.com"

# Set the working directory in the container
WORKDIR /workspace

# Copy the current directory contents into the container at /workspace
COPY . /workspace

# Define the default command to run when starting the container
CMD ["bash"]
```

Build the Dockerimage with  
```
docker build -t x86_64_enviornment .
```

Start the container with  
```
docker run -it --name x86_64 x86_64_enviornment
```

Afterwards, directly start docker with  
```
docker start -i x86_64
```

## CMake vs Makefile  
https://stackoverflow.com/questions/25789644/what-is-the-difference-between-using-a-makefile-and-cmake-to-compile-the-code  
To run CMake  
```
mkdir build
cd build
cmake .
make
```
Then directly run the program after successful compilation  
```
./helloworld
```

## Problems
Github commands "Failed to connect to github.com port 443 after 75040 ms: Couldn't connect to server"  
https://github.com/desktop/desktop/issues/13404  
```
git config --global --unset http.proxy
```

Sometimes github push doesn't work, directly copy files over  
```
docker cp /Users/jamesyen/Documents/RISC-V-Training/Fall_2023/Week-One/bubbleSort.s 9cf8fae0aaa1:/workspace/RISC-V-Training/Fall_2023/Week-One/
```

## Observe C code under different compilation settings
https://godbolt.org/  


## Benchmark code  
Create `.sh` file  
```
#!/bin/bash

# Path to the executables
executable_path="/workspace/RISC-V-Training/Fall_2023/Week-One/build"

# Increase the number of elements to 1000
num_elements=1000
elements=$(seq -s ' ' $num_elements -1 1)

# Number of runs for benchmarking
num_runs=10

echo "Benchmarking Bubble Sort Implementations"
echo "----------------------------------------"

# Function to benchmark a sorting executable
benchmark_sort() {
    local total_time=0
    local executable=$1
    local executable_name=$2

    echo "Benchmarking $executable_name"
    echo "----------------------------"

    for (( i=1; i<=num_runs; i++ ))
    do
        # Measure time of each run
        start_time=$(date +%s.%N)
        (echo "$num_elements"; echo "$elements") | "$executable_path/$executable" > /dev/null
        end_time=$(date +%s.%N)
        local runtime=$(echo "$end_time - $start_time" | bc -l)

        echo "Run $i: $runtime seconds"
        
        # Sum up the time
        total_time=$(echo "$total_time + $runtime" | bc -l)
    done

    # Calculate average time with increased precision
    local avg_time=$(echo "scale=5; $total_time / $num_runs" | bc -l)
    echo "Total time for $num_runs runs: $total_time seconds"
    echo "Average time for $executable_name: $avg_time seconds"
    echo ""
}

# Benchmark the C implementation
benchmark_sort "bubbleSort" "Bubble Sort in C"

# Benchmark the C and Assembly implementation
benchmark_sort "bubbleSortAssembly" "Bubble Sort in C and Assembly"
```

Copy over to docker  
```
docker cp /Users/jamesyen/Documents/RISC-V-Training/Fall_2023/Week-One/benchmark.sh 9cf8fae0aaa1:/workspace/RISC-V-Training/Fall_2023/Week-One/
```

Make sure `bc` is installed  
```
apt-get update
apt-get install bc
```

Give shell file correct permission before running   
```
chmod +x benchmark.sh
./benchmark.sh
```
