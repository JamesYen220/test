# Week two: Setting up enviornment and learning Makefile

Nice videos to watch: https://www.youtube.com/watch?v=Ps0JFsyX2fU&ab_channel=ExplainingComputers  
https://www.youtube.com/watch?v=kFT54hO1X8M&ab_channel=UBCComputerScience  
https://www.youtube.com/watch?v=HbgzrKJvDRw&ab_channel=DorianDotSlash  
https://www.youtube.com/watch?v=ghmvH26LnCY&ab_channel=ByteSeb  

**It is recommended to install VPN into VM**  
Reference document: https://yiy.one/article?id=17  
启动Clash: systemctl start clash  
关闭Clash: systemctl stop clash  
查看状态（可以用来检测是否成功启动）: systemctl status clash  
设置开机自启: systemctl enable clash  
取消开机自启: systemctl disable clash  
Change Makefile to reflect change on start  
```Makefile
load:
	qemu-system-aarch64 \
    -machine virt,accel=hvf \
    -cpu max \
    -smp 2 \
    -hda ubuntu-23.04-live-server-arm64.qcow2 \
    -cdrom ./ubuntu-23.04-live-server-arm64.iso \
    -m 2G \
    -device virtio-gpu-pci \
    -device usb-ehci \
    -device usb-kbd \
    -device usb-mouse \
    -bios QEMU_EFI.fd \
    -display default,show-cursor=on \
    -net user,hostfwd=tcp::2222-:22 \ -net nic


run:
	qemu-system-aarch64 \
    -monitor stdio \
    -M virt,highmem=off \
    -accel hvf \
    -cpu host \
    -smp 4 \
    -m 3000 \
    -bios QEMU_EFI.fd \
    -device virtio-gpu-pci \
    -display default,show-cursor=on \
    -device qemu-xhci \
    -device usb-kbd \
    -device usb-tablet \
    -device intel-hda \
    -device hda-duplex \
	-hda ubuntu-23.04-live-server-arm64.qcow2 \
    -net user,hostfwd=tcp::2222-:22,hostfwd=tcp::9090-:9090 \
    -net nic
```

**Copy file into Qemu**  
```bash
scp -P 2222  ./clash-linux-arm64-v1.16.0.gz james@127.0.0.1:/home/james
```

**Setting up SSH on Qemu Ubuntu**  
References: https://www.youtube.com/watch?v=8X4u9sca3Io&ab_channel=VictorGeislinger  
```bash
ssh-keygen -t ed25519 -C jamesyen2202002@gmail.com
```
<img width="541" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/f32305aa-1871-4db8-9790-7bfad4adf12f">  

```bash
eval "$(ssh-agent -s)"
ssh-add ~/.ssh/id_ed25519
```
<img width="510" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/9531f688-52aa-473b-b00e-3c27c57a6726">   

```bash
cat id_ed25519.pub
ssh-add ~/.ssh/id_ed25519
```
<img width="1294" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/89337153-538c-43ad-9e48-321049258780">  
<img width="851" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/9767495d-afb5-4bf9-afd6-7164742234c6">  

```bash
ssh -T git@github.com
```
<img width="611" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/01a4a06e-1061-46f6-ac47-231ccada0107">  


**Installing Riscv on Qemu Ubunutu**  
References: https://notes.sjtu.edu.cn/5U14HamvRQioIG2spTyazw  
```bash
sudo apt-get clean
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install git
```
somtimes sudo apt-get update might run into problems  
<img width="933" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/62a97b56-309e-4732-bbc6-71872cb0c9c3">  
reference:  https://github.com/MicrosoftDocs/WSL/issues/937
https://blog.csdn.net/u011291072/article/details/127375119  
run 
```bash
sudo sed -i "s@http://ports.ubuntu.com@https://mirrors.tuna.tsinghua.edu.cn@g" /etc/apt/sources.list
```
and then sudo apt-get update again, sometimes you might have to run sudo apt-get clean first  
```bash
sudo apt-get install autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libusb-1.0-0-dev device-tree-compiler pkg-config libnghttp2-dev libssl-dev -y
```
```bash
git clone https://github.com/riscv/riscv-fesvr.git
git clone --recursive https://github.com/riscv/riscv-tools.git
git clone --recursive git@github.com:riscv-collab/riscv-gnu-toolchain.git
```
Sometimes `git@github.com:riscv-collab/riscv-gnu-toolchain.git` might not work due to internet problems.  
references: https://blog.csdn.net/lizhao_yang_/article/details/121809405?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168780207816800222853567%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168780207816800222853567&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-121809405-null-null.142^v88^control_2,239^v2^insert_chatgpt&utm_term=Cloning%20into%20riscv-gnu-toolchain...%20fatal%3A%20unable%20to%20access%20https%3A%2F%2Fgithub.com%2Friscv%2Friscv-gnu-toolchain%2F%3A%20gnutls_handshake%28%29%20failed%3A%20The%20TLS%20connection%20was%20non-properly%20terminated.&spm=1018.2226.3001.4187  
In this case, we need to execute each of the libraries seperately  
```bash
cd riscv-gnu-toolchain
git clone --recursive https://git.qemu.org/git/qemu.git
git clone --recursive https://gitee.com/riscv-mcu/riscv-binutils-gdb.git riscv-binutils
git clone --recursive https://gitee.com/riscv-mcu/riscv-dejagnu.git
git clone --recursive https://gitee.com/riscv-mcu/riscv-gcc.git
git clone --recursive https://gitee.com/riscv-mcu/riscv-binutils-gdb.git riscv-gdb
git clone --recursive git://sourceware.org/git/glibc.git
git clone --recursive git://sourceware.org/git/newlib-cygwin.git
```
If error persist, try this  
references: https://blog.csdn.net/u013626215/article/details/105042064?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168785723216800192223155%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=168785723216800192223155&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105042064-null-null.142^v88^control_2,239^v2^insert_chatgpt&utm_term=fatal%3A%20early%20EOF%20fatal%3A%20fetch-pack%3A%20invalid%20index-pack%20output%20fatal%3A%20clone%20of%20https%3A%2F%2Fsourceware.org%2Fgit%2Fbinutils-gdb.git%20into%20submodule%20path%20%2Fhome%2Fjames%2Friscv-gnu-toolchain%2Fbinutils%20failed%20Failed&spm=1018.2226.3001.4187  
```bash
git config --global core.compression 0
```
And then run the git clone commands again  
```bash
echo "export RISCV=/usr/local/riscv" >> ~/.bashrc
echo "export PATH=\$PATH:\$RISCV/bin" >> ~/.bashrc
source ~/.bashrc
```
<img width="635" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/80efbf45-98b2-442a-ad48-2eb98968d616">  

```bash
cd riscv-gnu-toolchain/
mkdir build
cd build
../configure --prefix=$RISCV --enable-multilib
sudo make linux -j4
sudo make newlib -j4
```
Sometimes there might still be a problem with make:  
<img width="1446" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/95678288-932f-47d7-9ea5-fc29863f2a75">  
Reference: https://stackoverflow.com/questions/62416802/problem-to-build-riscv-toolchain-on-ubuntu  
```
git submodule update --init --recursive
```
Up to here this process should be done  
<img width="802" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/e4ff7c83-3f84-4450-a954-bad9f00e290f">  

```bash
cd riscv-fesvr
mkdir build
cd build
../configure --prefix=$RISCV --target=riscv64-unknown-elf
sudo make install
```
Might have the error  
<img width="679" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/97e52b1a-e857-4480-a5c5-9da8c3d748db">  
In this case, run 
```bash
../configure --prefix=$RISCV --target=riscv64-unknown-elf --build=aarch64-unknown-elf
sudo make install
```
However, sometimes, there might still be an error
<img width="1293" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/f97d5d9d-b9d1-4c20-a56f-bd98a2d8e46b">  
Reference: https://blog.csdn.net/weiyuweizhi/article/details/5712002   
In this case, add `#include<stdexcept>` located in `fesvr/dtm.cc`  
<img width="192" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/4b0228d2-77bc-47a4-b7f8-4b08ea828dc1">  
Now rerun 
```bash
sudo make install
```
This part(toolchain prefixed with elf) should be finished here  
<img width="1579" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/e4d19b20-c369-455a-9444-c269c33a3b7f">  
Next, we also need compile the linux-gnu version  
```bash
../configure --prefix=$RISCV --target=riscv64-unknown-linux-gnu --build=aarch64-unknown-linux-gnu
sudo make install
```
<img width="559" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/76e79732-459d-4757-8c4c-cffa9b39dc29"> 

```bash
cd riscv-tools
sudo su
export RISCV=/opt/riscv
./build-spike-pk.sh
```

<img width="609" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/4d6d8134-f675-4356-8a73-d35c99e2cb56">  

In this case, change `../configure $* > build.log` to `../configure --build=aarch64-unknown-linux-gnu $* > build.log` in the `build.common` file  
<img width="527" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/fb628d19-464d-4854-b2da-123990d3ca97">  

However, there may still be an error  
<img width="625" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/c31ebfb2-5877-421a-9ab0-12b810e77130">   

This is similar to the error in the riscv-fesvr  
Add `#include<stdexcept>` located in `riscv-isa-sim/fesvr/dtm.cc`  
<img width="194" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/e987dc24-8a42-4679-88ed-de949654e833">  

Now rerun  
```bash
export RISCV=/opt/riscv
./build-spike-pk.sh
```

There might be a problem similar to the one above 
<img width="798" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/bb0210c7-f20d-4116-bbe6-9692f14f3683">  

Add `#include<stdexcept>` located in `riscv-isa-sim/fesvr/devices.h`  
<img width="179" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/3337189e-8a70-4eaf-b7f3-d21d30f7369a">  

Now rerun  
```bash
export RISCV=/opt/riscv
./build-spike-pk.sh
```
<img width="1106" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/081cd79a-a202-45a1-a500-489f97fe6882">   

After looking at the config.log, we can see that the compiler is using riscv64-unknown-elf  
<img width="694" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/d9542931-a536-4b9c-bbf5-aff1ff963c27">  
<img width="733" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/1e17b43c-714e-43b1-af88-e9e139a5de83">  
"riscv64-unknown-elf" is a bare-metal toolchain that produces executables without any operating system dependencies. It is commonly used for developing firmware or low-level software that runs directly on RISC-V hardware without an operating system. If you're working on such projects, "riscv64-unknown-elf" would be appropriate. On the other hand, "riscv64-unknown-linux-gnu" is a toolchain that targets Linux-based systems on RISC-V architecture. It allows you to build executables that run on RISC-V systems running the Linux operating system. If you're developing applications or software that require Linux-specific features, system calls, or libraries, "riscv64-unknown-linux-gnu" would be the better choice. In the context of running ARM QEMU on Ubuntu, if you're emulating a RISC-V system that has a Linux operating system installed, you should use "riscv64-unknown-linux-gnu" toolchain to compile your software. This way, you can build and run applications that are compatible with the emulated Linux environment.  

Change the `build-spike-pk.sh` according to match riscv64-unknown-linux-gnu  
```Makefile
#! /bin/bash
#
# Script to build RISC-V ISA simulator, proxy kernel, and GNU toolchain.
# Tools will be installed to $RISCV.

. build.common

if [ ! `which riscv64-unknown-linux-gnu-gcc` ]
then
  echo "riscv64-unknown-linux-gnu-gcc doesn't appear to be installed; use the full-on build.sh"
  exit 1
fi

echo "Starting RISC-V Toolchain build process"

build_project riscv-isa-sim --prefix=$RISCV
CC=riscv64-unknown-linux-gnu-gcc CXX=riscv64-unknown-linux-gnu-g++ build_project riscv-pk --prefix=$RISCV --host=riscv64-unknown-linux-gnu --with-arch=rv64gc_zifencei

echo -e "\\nRISC-V Toolchain installation completed!"
```

Next, following the reference below to fix some minior bugs  
Reference: https://blog.csdn.net/huang_k_f/article/details/130882369  
First, add `extern` infront of `tohost` `fromhost` in the path `riscv-tests/env/v/vm.c`  
<img width="346" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/4a1530ca-267a-4e25-a7bc-95ba74a98938">  
Next, add `#pragma GCC push_options` and `#pragma GCC pop_options` before and after the `memset` function in the path `riscv-pk/util/string.c`  
<img width="558" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/81280c99-d42f-4b94-9675-de8bbf5b8b53">  

After running `./build-spike-pk.sh` again we meet the error  
<img width="929" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/67ac9cba-0b89-4974-8df8-2e80a124521c">  
The stubs-lp64.h file should be located in the /usr/include/gnu/ directory (or /usr/local/include/gnu/ or similar depending on your system setup). If it's not there, you might have to manually add it.  
Use the command `find / -name "gnu" 2>/dev/null` to find the correct path   
```bash
cp /home/james/riscv-gnu-toolchain/glibc/include/gnu/stubs-lp64d.h /home/james/riscv-gnu-toolchain/glibc/include/gnu/stubs-lp64.h
```
Sometimes the `spike` command isn't found  
<img width="377" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/9237e6fb-665b-420e-9e5d-ba227ba177f2">  
Look for where the `spike` command is stored first  
```bash
# Find the path to the spike executable
find / -name spike 2>/dev/null
```
Next, add the path to your `bash`  
```bash
vi ~/.bashrc
source ~/.bashrc
```
<img width="325" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/1ae427e3-3895-49cc-b32b-a9bb2544ffdc">  


Up to here, this part of the installation should be complete  
<img width="930" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/39f6499b-aebf-4cdf-9080-0b179a3a166e">  

Create a helloworld.c program  
```c
#include <stdio.h>

int main(void)
{
        printf("hello world!\n");
        return 0;
}
```
Run `riscv64-unknown-linux-gnu-gcc -static -o helloworld helloworld.c` creating the executable  
```bash
spike /root/riscv/toolchain/riscv64-unknown-linux-gnu/bin/pk ./helloworld
```
<img width="902" alt="image" src="https://github.com/JamesYen220/RiscV-SummerTraining/assets/100248639/c327ea62-b25d-49ec-bde0-7d3f97cbd23f">  

**Studying Makefile**  
First Makefile source: https://github.com/ptitSeb/box64/blob/main/LLVMprivateGenerator/Makefile  
```makefile
all: dumpSigs

dumpSigs: main.o registered_structs.o
	g++ -g3 -std=gnu++17 -fno-rtti main.o registered_structs.o -o dumpSigs "-L$(LLVM_install_dir)/lib" -lclang-cpp -lclangTooling -Wl,-rpath "-Wl,$(LLVM_install_dir)/lib"

main.o: main.cpp
	g++ -g3 -std=gnu++17 -fno-rtti -c main.cpp -Wfatal-errors "-I$(LLVM_install_dir)/include" -o main.o
registered_structs.o: registered_structs.cpp
	g++ -g3 -std=gnu++17 -fno-rtti -c registered_structs.cpp -Wfatal-errors -o registered_structs.o

clean:
	$(RM) dumpSigs main.o registered_structs.o
```
A Makefile organizes targets and dependencies in a hierarchical manner. In the Makefile you provided, to build the all target, it first needs to build the dumpSigs target, which in turn depends on main.o and registered_structs.o targets. Each target in a Makefile has a list of dependencies and a command to be executed.

1. `all: dumpSigs`: This is a rule that specifies how to build the `all` target. The `all` target is typically used to build all executables and other non-source files of a program from the program's source files. In this case, `dumpSigs` is a dependency of `all`, which means `all` will not be built until `dumpSigs` is built.

2. `dumpSigs: main.o registered_structs.o`: This line specifies that `dumpSigs` depends on `main.o` and `registered_structs.o`. In other words, if either `main.o` or `registered_structs.o` is newer than `dumpSigs`, or if `dumpSigs` does not exist, then `dumpSigs` will be built.

3. `g++ -g3 -std=gnu++17 -fno-rtti main.o registered_structs.o -o dumpSigs "-L$(LLVM_install_dir)/lib" -lclang-cpp -lclangTooling -Wl,-rpath "-Wl,$(LLVM_install_dir)/lib"`: This command is executed to build `dumpSigs`. It links `main.o` and `registered_structs.o` together using the g++ compiler with specific flags and libraries.
   - **g++**: This is the C++ compiler. It's being used to link the object files into an executable.
   - **-g3**: This flag includes extra debugging information in the output. This makes debugging the program easier, but it can make the program and the debug information larger.
   - **-std=gnu++17**: This flag tells the compiler to adhere to the C++17 standard with GNU extensions.
   - **-fno-rtti**: This flag disables RTTI (Run-Time Type Information). RTTI is a mechanism that allows the type of an object to be determined during runtime. Disabling it can result in smaller and faster code, but you can't use certain features like dynamic_cast and typeinfo.
   - **main.o registered_structs.o**: These are the object files to be linked together to create the executable.
   - **-o dumpSigs**: This flag tells the compiler to output the resulting executable as `dumpSigs`.
   - **"-L$(LLVM_install_dir)/lib"**: This flag tells the linker to look in the directory `$(LLVM_install_dir)/lib` for library files to link against. `$(LLVM_install_dir)` is a variable which would be defined elsewhere in your build system.
   - **-lclang-cpp -lclangTooling**: These flags tell the linker to link against the `libclang-cpp` and `libclangTooling` libraries.
   - **-Wl,-rpath "-Wl,$(LLVM_install_dir)/lib"**: This is passing options directly to the linker. The `-rpath` option sets the runtime library search path to the given directory, which in this case is `$(LLVM_install_dir)/lib`. This means that when `dumpSigs` is executed, it will look for its dynamic libraries in that directory.

4. `main.o: main.cpp`: This line creates a rule for building `main.o` from `main.cpp`. If `main.cpp` is newer than `main.o`, or if `main.o` does not exist, then `main.o` will be built.

5. `g++ -g3 -std=gnu++17 -fno-rtti -c main.cpp -Wfatal-errors "-I$(LLVM_install_dir)/include" -o main.o`: This command is executed to build `main.o`. It compiles `main.cpp` to `main.o` using the g++ compiler with specific flags and includes.
   - **-c main.cpp**: The `-c` flag tells the compiler to generate an object file rather than an executable. `main.cpp` is the source file to be compiled.
   - **-Wfatal-errors**: This flag makes all warnings into errors, which will cause the compilation to stop at the first error encountered.
   - **"-I$(LLVM_install_dir)/include"**: The `-I` flag is followed by a directory where the compiler should look for include files. `$(LLVM_install_dir)/include` is the directory to be added to the list where the compiler looks for include files.
   - **-o main.o**: The `-o` flag is followed by the name of the output file. In this case, `main.o` is the output file. This is the object file that will be created by the compiler.

6. `registered_structs.o: registered_structs.cpp`: This line creates a rule for building `registered_structs.o` from `registered_structs.cpp`. If `registered_structs.cpp` is newer than `registered_structs.o`, or if `registered_structs.o` does not exist, then `registered_structs.o` will be built.

7. `g++ -g3 -std=gnu++17 -fno-rtti -c registered_structs.cpp -Wfatal-errors -o registered_structs.o`: This command is executed to build `registered_structs.o`. It compiles `registered_structs.cpp` to `registered_structs.o` using the g++ compiler with specific flags.

8. `clean:`: This line creates a rule for the `clean` target. The `clean` target is typically used to remove all files that can be regenerated with make. It doesn't have any dependencies.

9. `$(RM) dumpSigs main.o registered_structs.o`: This command is executed when the `clean` target is built. It removes the `dumpSigs`, `main.o`, and `registered_structs.o` files【5†source】.

Second Makefile source: https://github.com/riscv-collab/riscv-gnu-toolchain/blob/master/regression/Makefile  
```makefile
.SECONDARY:
report:

# The list of target tuples that we want to test.
TARGETS  =
TARGETS += newlib-rv32i-ilp32-medlow
TARGETS += newlib-rv32im-ilp32-medlow
TARGETS += newlib-rv32iac-ilp32-medlow
TARGETS += newlib-rv32imac-ilp32-medlow
TARGETS += newlib-rv32imafc-ilp32f-medlow
TARGETS += newlib-rv64imac-lp64-medlow
TARGETS += newlib-rv64imafdc-lp64d-medlow
TARGETS += linux-rv32imac-ilp32-medlow
TARGETS += linux-rv32imafdc-ilp32-medlow
TARGETS += linux-rv32imafdc-ilp32d-medlow
TARGETS += linux-rv64imac-lp64-medlow
TARGETS += linux-rv64imafdc-lp64-medlow
TARGETS += linux-rv64imafdc-lp64d-medlow
TARGETS += newlib-rv32i-ilp32-medany
TARGETS += newlib-rv32im-ilp32-medany
TARGETS += newlib-rv32iac-ilp32-medany
TARGETS += newlib-rv32imac-ilp32-medany
TARGETS += newlib-rv32imafc-ilp32f-medany
TARGETS += newlib-rv64imac-lp64-medany
TARGETS += newlib-rv64imafdc-lp64d-medany
TARGETS += linux-rv32imac-ilp32-medany
TARGETS += linux-rv32imafdc-ilp32-medany
TARGETS += linux-rv32imafdc-ilp32d-medany
TARGETS += linux-rv64imac-lp64-medany
TARGETS += linux-rv64imafdc-lp64-medany
TARGETS += linux-rv64imafdc-lp64d-medany

# This is the link between the report targets and the actual testsuite
# build/test runs.  It's setup with a level of indirection here to make sure
# that when running "make report" we run all the test suites before running any
# of the reports.  Since the various check targets are never supposed to fail,
# this lets me ensure that re-running "make report" is always fast.
.PHONY: build
build: $(addprefix stamps/build-,$(TARGETS))

.PHONY: check
check: $(addprefix stamps/check-,$(TARGETS))

.PHONY: check-%
check-%: stamps/check-%

.PHONY: build-%
build-%: stamps/build-%

.PHONY: report
report: check
	$(MAKE) $(addprefix report-gcc-,$(TARGETS))

.PHONY: report-gcc-%
report-gcc-%: stamps/check-%
	$(eval $@_BUILDDIR := build/$(patsubst report-gcc-%,%,$(notdir $@)))
	$(MAKE) -C $($@_BUILDDIR) report

.PHONY: report-binutils
report-binutils: check
	$(MAKE) $(addprefix report-binutils-,$(TARGETS))

.PHONY: report-binutils-%
report-binutils-%: stamps/check-%
	$(eval $@_BUILDDIR := build/$(patsubst report-binutils-%,%,$(notdir $@)))
	$(MAKE) -C $($@_BUILDDIR) report-binutils

# These rules call into the above Makefile to actually test the various
# toolchain targets we care about.
stamps/configure-%:
	$(eval $@_BUILDDIR := build/$(patsubst configure-%,%,$(notdir $@)))
	$(eval $@_PREFIX := install/$(patsubst configure-%,%,$(notdir $@)))
	$(eval $@_LINUX := $(if $(filter linux,$(word 2,$(subst -, ,$(notdir $@)))),--enable-linux,--disable-linux))
	$(eval $@_MARCH := $(word 3,$(subst -, ,$(notdir $@))))
	$(eval $@_MABI := $(word 4,$(subst -, ,$(notdir $@))))
	$(eval $@_MCMODEL := $(word 5,$(subst -, ,$(notdir $@))))
	mkdir -p $($@_BUILDDIR)
	cd $($@_BUILDDIR); $(abspath ../configure) \
		$($@_LINUX) \
		--disable-multilib \
		--prefix=$(abspath $($@_PREFIX)) \
		--with-arch=$($@_MARCH) \
		--with-abi=$($@_MABI) \
		--with-cmodel=$($@_MCMODEL)
	mkdir -p $(dir $@)
	date > $@

stamps/build-%: stamps/configure-%
	$(eval $@_BUILDDIR := build/$(patsubst build-%,%,$(notdir $@)))
	$(eval $@_PREFIX := install/$(patsubst build-%,%,$(notdir $@)))
	$(MAKE) -C $($@_BUILDDIR)
	mkdir -p $(dir $@)
	echo 'export PATH="$(abspath $($@_PREFIX))/bin:$$PATH"' > $($@_PREFIX)/enter.bash
	date > $@

stamps/check-%: stamps/build-%
	$(eval $@_BUILDDIR := build/$(patsubst check-%,%,$(notdir $@)))
	$(MAKE) -C $($@_BUILDDIR) check
	mkdir -p $(dir $@)
	date > $@

# Cleans up after a run
.PHONY: clean
clean::
	rm -rf build install stamps
```
The script is a makefile, which is a file containing a set of directives used with the `make` build automation tool. `make` reads this file to figure out how to convert source code files into executable programs or libraries. This makefile appears to be setting up a series of build and test procedures for a number of different target configurations.

Here's a line-by-line explanation of the script:

1. `.SECONDARY:`: This tells `make` to treat the targets as secondary. This means that `make` will not remove these targets if they are intermediate results used to build other targets.

2. `report:`: This is the declaration of a target named `report`. It doesn't have dependencies or commands, so it seems to be a placeholder or a default target.

3. `TARGETS  =`: The `TARGETS` variable is being defined and initially set to an empty string.

4. `TARGETS += newlib-rv32i-ilp32-medlow` and the following lines: The `TARGETS` variable is being appended with a number of strings, each representing a different target configuration.

5. `.PHONY: build`: This declares `build` as a phony target. Phony targets are always out-of-date and thus commands associated with them are always executed. When you run a phony target, the associated recipe is executed regardless of whether a file with the same name exists or not.

	- The `build: $(addprefix stamps/build-,$(TARGETS))` line in the makefile is defining a target named `build`, which depends on a list of other targets. The list of dependencies is created using the `addprefix` function, which prepends `stamps/build-` to each item in `$(TARGETS)`. So, for example, if `TARGETS` includes `newlib-rv32i-ilp32-medlow`, then `build` would depend on `stamps/build-newlib-rv32i-ilp32-medlow`.  
	
	- When `make build` is run, `make` will attempt to build all the targets in this list before building `build`. In this case, "building" these targets means running the commands associated with them. Let's look specifically at what happens when `make` builds `stamps/build-%`, since that's what the `build` target depends on:  
	
	- `stamps/build-%: stamps/configure-%`: This line is a pattern rule that matches any target that starts with `stamps/build-`. It says that each of these targets depends on a corresponding `stamps/configure-` target. So before `make` can build `stamps/build-newlib-rv32i-ilp32-medlow`, for example, it must first build `stamps/configure-newlib-rv32i-ilp32-medlow`.  
	
	- `$(eval $@_BUILDDIR := build/$(patsubst build-%,%,$(notdir $@)))`: This line uses the eval function to evaluate the expression on the right and assign it to the variable $@_BUILDDIR. The value of `_BUILDDIR` is `build/` followed by the part of the target name after `build-`. So if the target is `stamps/build-newlib-rv32i-ilp32-medlow`, `_BUILDDIR` would be `build/newlib-rv32i-ilp32-medlow`.  This line is a dynamic evaluation statement that sets the variable "$@_BUILDDIR" to a value. "$@" represents the target name being built. Here, it appends "build/" to the beginning of the target name while removing the "build-" prefix using the "patsubst" function. The "notdir" function extracts the target name without any directory components. Ultimately, this line sets the variable `$@_BUILDDIR` to the constructed build directory path. The notdir `$@` part extracts the target name without any directory components. Then, the patsubst report-gcc-%,% portion replaces the prefix "report-gcc-" with an empty string, effectively removing it from the target name. For example, if the target name is `report-gcc-foo`, the patsubst function will transform it to "foo". It allows you to obtain the remaining part of the target name without the prefix. The purpose of this transformation is to generate the corresponding directory name under the "build/" directory, so that different targets like `report-gcc-foo` and `report-gcc-bar` will have their respective build directories "build/foo" and "build/bar". For example, if you run the command make build-foo, it will execute the recipe associated with the target "build-foo." The eval command will be triggered, and the `$@_BUILDDIR` variable will be set to "build/foo." 
	
	- `$(eval $@_PREFIX := install/$(patsubst build-%,%,$(notdir $@)))`: This is similar to the previous line, but it's defining a `_PREFIX` variable with a value of `install/` followed by the part of the target name after `build-`.  
	
	- `$(MAKE) -C $($@_BUILDDIR)`: This line is running `make` in the directory specified by `_BUILDDIR`. For example, `$(MAKE) -C $($@_BUILDDIR) report-binutils`. If the eval command returns "build/foo" (as an example) for `$@_BUILDDIR`, the $(MAKE) command will change the directory using the -C flag and execute make in the "build/foo" directory. Assuming the "build/foo" directory contains its own Makefile with a target named "report-binutils," the second line will invoke the make command within that directory with the target "report-binutils". This allows for building the specific target "report-binutils" in the "build/foo" directory.  
	
	- `mkdir -p $(dir $@)`: This line is creating the directory that the current target is in, if it doesn't already exist.  
	
	- `echo 'export PATH="$(abspath $($@_PREFIX))/bin:$$PATH"' > $($@_PREFIX)/enter.bash`: This line is creating a file named `enter.bash` in the `_PREFIX` directory. The file contains a line of bash code that adds the `bin` directory in `_PREFIX` to the `PATH`.  
	
	- `date > $@`: This line is creating a file with the name of the current target (like `stamps/build-newlib-rv32i-ilp32-medlow`), and the contents of the file is the current date and time. This is often done in makefiles to keep track of when different targets were last built.  

6. `build: $(addprefix stamps/build-,$(TARGETS))`: This line declares a dependency of the `build` target on a number of other targets. It uses the `addprefix` function to prepend `stamps/build-` to each of the values in `TARGETS`.

7. The `check`, `check-%`, `build-%` targets are similarly defined with respective dependencies. In a Makefile, the percent sign (%) is a special character known as a wildcard or pattern rule. It is used to match any sequence of characters in a target or prerequisite. "check-%: stamps/check-%", specifies that for any target that matches the pattern "check-", the corresponding prerequisite will be "stamps/check-". This means that if you invoke a target like "check-foo", the prerequisite "stamps/check-foo" will be checked to determine if it is up to date or needs to be rebuilt.

8. `report: check`: This states that `report` depends on `check`. So when `report` is built, `make` will first build `check`.

9. `$(MAKE) $(addprefix report-gcc-,$(TARGETS))`: This line is a command that runs `make` on a number of other targets. It uses the `addprefix` function to prepend `report-gcc-` to each of the values in `TARGETS`. The "make" command is called recursively. It uses the variable `$@_BUILDDIR` (which was set in the previous step) to specify the directory where the sub-make command should be executed. The target "report" is passed to the sub-make command.

10. `report-gcc-%: stamps/check-%`: This defines a pattern rule for targets that start with `report-gcc-`. Each of these targets depends on a corresponding `stamps/check-` target. Normally, when you write a Makefile, you define rules and targets directly in the file. However, with `eval`, you can generate those rules and targets on the fly while the Makefile is being processed. `eval` takes a piece of text or a variable and treats it as if it were written directly in the Makefile. This means you can create rules, set variables, or execute any other Makefile statements based on conditions or dynamic data. It enables you to generate and execute Makefile code dynamically, tailoring the build process based on various factors. By using `eval`, you have more control over the generation and modification of Makefile code during the build process, allowing for flexibility and customization based on your specific needs.

11. The following lines within `report-gcc-%` rule uses the `eval` function to create and assign values to several variables, then calls `make` on a `report` target in the corresponding build directory.

12. The `report-binutils` and `report-binutils-%` rules are similar to the `report` and `report-gcc-%` rules, but they work with `report-binutils-` prefixed targets.

13. `stamps/configure-%:`: This defines a pattern rule for targets that start with `stamps/configure-`. It creates and assigns values to several variables based on the target name, then runs a configure script with those variables.
	- `$(eval $@_LINUX := $(if $(filter linux,$(word 2,$(subst -, ,$(notdir $@)))),--enable-linux,--disable-linux))`: Here, it checks if the second word in the target name (after splitting by `-`) is `linux`. If it is, `$@_LINUX` is assigned `--enable-linux`; otherwise, it's assigned `--disable-linux`.  
 	- The next three lines (`$@_MARCH`, `$@_MABI`, `$@_MCMODEL`) are similar, except they extract the third, fourth, and fifth words from the target name respectively.  
This is a rule in a Makefile that generates a stamp (a timestamp file) for each configuration step of a build process.
	- `mkdir -p $($@_BUILDDIR)`: This creates the build directory if it does not already exist.
 	- `cd $($@_BUILDDIR); $(abspath ../configure) \`: This changes the working directory to the build directory and executes the `configure` script in the parent directory. The `abspath` function returns the absolute path of `../configure`. The next six lines specify the options passed to the `configure` script. The backslash (\) at the end of the line is used to indicate that the command continues on the next line.  
  	- `mkdir -p $(dir $@)`: This creates the directory for the stamp file if it does not already exist. `dir` returns the directory part of the target name.
   	- `date > $@`: This writes the current date and time to the stamp file. The `$@` variable here represents the full target name, so it creates a timestamp file with the name of the target.
 
14. `stamps/build-%: stamps/configure-%`: This defines a pattern rule for targets that start with `stamps/build-`. Each of these targets depends on a corresponding `stamps/configure-` target. It builds the configured target and creates an `enter.bash` script in the install directory that sets the `PATH` to include the bin directory of the installed target.

15. `stamps/check-%: stamps/build-%`: This defines a pattern rule for targets that start with `stamps/check-`. Each of these targets depends on a corresponding `stamps/build-` target. It runs a check on the built target.

16. `.PHONY: clean`: This declares `clean` as a phony target.

17. `clean::`: This line declares a target named `clean`. When the `clean` target is built, the commands associated with it are executed.

18. `rm -rf build install stamps`: This is the command associated with the `clean` target. It removes the `build`, `install`, and `stamps` directories, cleaning up the build environment.

Each target goes through a process of configuration (`configure-%`), building (`build-%`), and checking (`check-%`). The build results are timestamped and stored in directories named `stamps`. There are also rules for creating reports on the `gcc` and `binutils` for each target (`report-gcc-%` and `report-binutils-%`), suggesting that this process is testing some aspect of these tools for each target configuration.
